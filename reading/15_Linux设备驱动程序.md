> 1.内核模块和应用程序的区别
>
> 2.驱动分类（）
>
> 3.编写helloworld驱动程序
>
> 4.在编写helloworld还应该知道的知识
>
> 驱动的出口和入口在编写时，需注意，应当编写成静态函数，虽内核没有强制要求，但是其他地方不会用到（p23）
>
> 在驱动入口的初始化函数里，由于内核超小的栈决定了，几乎必定会在驱动进行动态内存分配等。在注册驱动是一定有可能会注册失败的，所以在模块代码中必须时刻保证检查返回值，并且要求的操作已经成功。
>
> 由于是驱动，底层的，无论如何，也要尽力保证哪怕某一步的操作失败都有可替代选项或降级选项，来保证驱动可以正常的运行下去；实在是发生重大错误或失败时也要具备料理后事的能力。
>
> 这个料理后事的能力是指在一个特别类型的失败后完全不能加载, 你必须取消任何在失败前注册
> 的动作. 内核不保留已经注册的设施的每模块注册, 因此如果初始化在某个点失败, 模块必须能自己退回所有东西。如果不具备这个能力，内核极大可能的会运行在一个不稳定状态，不知道在什么时候就会崩溃。
>
> 料理的方法。虽然在正常编程中极不推荐goto方法，因为它会使代码逻辑变得混乱，难以理解，根据《软件开发的201个原则--第92-程序首先是写给人看的》所说代码应该是易于理解的

第二篇中

makefile修改一下

```makefile
KER_DRI=/home/wbyq/work/linux-3.5/linux-3.5
all:
    make -C $(KER_DRI) M=`pwd` modules
clean:
    make -C $(KER_DRI) M=`pwd` modules clean
obj-m += drv_hello.o

```

且在开头加一段话，里面主要说的是为什么不先写预备知识再写helloworld。其中有一个原因，就是有些学东西很心急。所以就先写了。

驱动分类（暂留）

主要讲述，Linux驱动主要是分为哪些种类，每种的区别和相同点



驱动预备知识的补充（暂留）

编写驱动前应该知道的预备知识（暂留）

这一部分将上一节中的预备知识和最后的init和exit给单独领到这里来.



> 测试代码写完，进行编译，编译完运行

让Hello world驱动跑起来（暂留）

挂载、卸载

版本依赖

驱动是紧密结合到一个特殊的内核版本的数据结构和函数原型上的；一个模块所看见的内核接口可能因内核版本的不同会有很大的差异性。所以你**编写的模块驱动代码要针对每一个内核驱动版本都应该重新编译**。

当然并不是说内核是就认在他这个版本上所建立的驱动，其他的驱动就不理睬，更重要的原因是，驱动是高度适配特定的内核的；在适配的第一步对是一个当前内核树中的文件(称为 vermagic.o)连接你的模块; 这个东东含有相当多的有关要为其建立模块的内核的信息, 包括目标内核版本, 编译器版本, 以及许多重要配置变量的设置. 当尝试加载一个模块, 这些信息被检查与运行内核的兼容性. 如果不匹配, 模块不会加载; 代之的是你见到如下内容:

```shell
insmod hello.ko
Error inserting './hello.ko': -1 Invalid module format
#/var/log/message
```

> 跨版本发行多版本 p19

当然，因驱动高度依赖内核源码，想要对驱动进行开发，那必须在你的开发文件夹里有系统内核源码，并且在编译驱动时，就已经确保内核已经编译完成。

平台依赖

略、暂时没看懂







并发竞争（暂留）

锁（暂留）

printk等调试技术（暂留）

定时器（暂留）

时钟和中断

字符设备（暂留）

ioctl

内存管理（暂留）





这篇文章有提到[杂项设备框架](https://xie.infoq.cn/article/342e768c313767141e8c994f0),所以杂项设备是什么样的存在，与其他设备的不同之处在哪





































### ismod命令

```c
//insmod_main()函数在modutils/insmod.c
insmod_main()
	parse_cmdline_module_options() //解析insmod命令加载驱动时给驱动的传参
	bb_init_module()			
		try_to_mmap_module()		//将驱动文件映射到内存中
		init_module()				//真正的开始加载驱动文件

```



### 编译模块

```makefile
#编译器
CROSS_COMPILE: ?= mips-linux-gnu
#指明内核源码路径
ENV_KERNEL_DIR ?= $(PWD)/../../kernel
KDIR := ${ENV_KERNEL_DIR}
#编译模块hello
obj-m:= hello.o
#该模块的源文件
module-objs := file1.o file2.o

```

### 加载和卸载模块

 insmod: 它依赖一个在 kernel/module.c 中定义 的系统调用. 函数 sys_init_module分配内核内存来存放模块(这个内存用vmalloc分配; 看第8章的 "vmalloc 和其友" ); 它接着拷贝模块的代码段到这块内存区, 借助内核符号表解决模块中的内核引用, 并且调用模块的初始化函数来启动所有东西. 

#### 系统调用函数

系统调用的函数的名字以 sys_为前缀，这对于任何系统都是成立的，并且没有其他函数

```shell
insmod hello.ko      	挂载（加载）模块（驱动）
rmmod hello     		卸载（加载）模块（驱动）
lsmod
```

lsmod 程序生成一个内核中当前加载的模块的列表. 一些其他信息, 例如使用了一个特定模块的其他模块, 也提供了. lsmod 通过读取 /proc/modules 虚拟文件工作. 当前加载的模块的信息也可在位于 /sys/module 的 sysfs 虚拟文件系统找到. 

#### 版本依赖

模块代码一定要为每个它要连接的内核版本重新编译 -- 至少, 在缺乏  modversions 时, 这里不涉及因为它们更多的是给内核发布制作者, 而不是开发者. 模块 是紧密结合到一个特殊内核版本的数据结构和函数原型上的; 模块见到的接口可能一个内核版本与另一个有很大差别. 当然, 在开发中的内核更加是这样. 

### 预备知识

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/version.h>

//module.h包含了大量加载模块的函数
//init.h包含了初始化和清理函数
//version.h包含在简历的内核版本信息

MODULE_LICENSE("GPL");//内核人事的特定许可
//GPL===>适用GNU通用公共许可的任何版本
//GPL v2===>只适用GPL的版本2
MODULE_AUTHOR("");//声明是谁编写的该模块
MODULE_DESCRIPION("");//该模块是干嘛的描述
MODULE_VERSION("");//模块版本
MODULE_ALIAS("");//模块的另一个为人所知的名称
MODULE_DEVICE_TABLE();//模块支持哪些设备

LINUX_VERSION_CODE;	//整型宏定义, 对 #ifdef 版本依赖有用.

EXPORT_SYMBOL (symbol);
EXPORT_SYMBOL_GPL (symbol);
//宏定义, 用来输出一个符号给内核. 第 2 种形式输出没有版本信息, 第 3 种限制输出给 GPL 许可的模块.
    
#include <linux/moduleparam.h>
module_param(variable, type, perm);
//宏定义, 创建模块参数, 可以被用户在模块加载时调整( 或者在启动时间, 对于内嵌代码). 类型可以是 bool, charp, int, invbool, short, ushort, uint, ulong,或者 intarray.

#include <linux/kernel.h>
int printk(const char * fmt, ...);
//内核代码的 printf 类似物.
```





### 模块初始化和关停

#### moudle_init（）

使用 moudle_init 是强制的. 这个宏定义增加了特别的段到模块目标代码中, 表明在哪里找到模块的初始化函数. 没有这个定义, 你的初始化函数不会被调用.

#### module_exit()

如果你的模块没有定义一个清理函数, 内核不会允许它被卸载.

一个标识 __exit 的函数只在模块卸载或者系统停止时调用; 任何别的使用是错的. 其次, moudle_exit 声明对于使得内核能够找到你的清理函数是必要的.

#### 初始化原则

注册内核设备时，可能会失败

1.模块代码必须检查返回值

2.注册过程中出现错误，在任何可能的时候, 你的模块应当尽力向前, 并提供事情失败后具备的能力.

3.确定模块出现错误无法再进行加载时，必须取消任何在失败前注册的动作. 内核不保留已经注册的设施的每模块注册, 因此如果初始化在某个点失败, 模块必须能自己退回所有东西

4.错误恢复时，可以使用goto，虽然通常不愿意使用goto

5.模块清理函数必须撤销任何由初始化函数进行的注册, 并且惯例(但常常不是要求的)是按照注册时相反的顺序注销设施.与此同时在销毁前需判断该变量是否存在，避免对NULL的free操作

#### 模块参数传递

```c
static char *whom = "world";
static int howmany = 1;
module_param(howmany, int, S_IRUGO);
module_param(whom, charp, S_IRUGO);
```

模块参数支持许多类型:
bool
invbool
		一个布尔型( true 或者 false)值(相关的变量应当是 int 类型). invbool 类型颠倒了值, 所以真值变成 false, 反之亦然.
charp
		一个字符指针值. 内存为用户提供的字串分配, 指针因此设置.
int
long
short
uint
ulong
ushort
		基本的变长整型值. 以 u 开头的是无符号值.

数组参数, 用逗号间隔的列表提供的值, 模块加载者也支持. 声明一个数组参数, 使用:
module_param_array(name,type,num,perm);

这里 name 是你的数组的名子(也是参数名), type 是数组元素的类型, num 是一个整型变
量, perm 是通常的权限值. 如果数组参数在加载时设置, num 被设置成提供的数的个数.
模块加载者拒绝比数组能放下的多的值.

> 注：
>
> 所有的模块参数应当给定一个缺省值;
> insmod 只在用户明确告知它的时候才改变这些值. 模块可检查明显的参数, 通过对应它们
> 的缺省值检查这些参数.



###### 在用户空间编写驱动

一个第一次涉及内核问题的 Unix 程序员, 可能会紧张写一个模块. 编写一个用户程序来直接读写设备端口可能容易些.
		确实, 有几个论据倾向于用户空间编程, 有时编写一个所谓的用户空间设备驱动对比钻研内核是一个明智的选择. 在本节, 我们讨论几个理由, 为什么你可能在用户空间编写驱动.本书是关于内核空间驱动的, 但是, 所以我们不超越这个介绍性的讨论.

用户空间驱动的好处在于:

- 完整的 C 库可以连接. 驱动可以进行许多奇怪的任务, 不用依靠外面的程序(实现使用策略的工具程序, 常常随着驱动自身发布).
- 程序员可以在驱动代码上运行常用的调试器, 而不必走调试一个运行中的内核的弯路.
- 如果一个用户空间驱动挂起了, 你可简单地杀掉它. 驱动的问题不可能挂起整个系统, 除非被控制的硬件真的疯掉了.
- 用户内存是可交换的, 不象内核内存. 一个不常使用的却有很大一个驱动的设备不会占据别的程序可以用到的 RAM, 除了在它实际在用时.
- 一个精心设计的驱动程序仍然可以, 如同内核空间驱动, 允许对设备的并行存取.
- 如果你必须编写一个封闭源码的驱动, 用户空间的选项使你容易避免不明朗的许可的情况和改变的内核接口带来的问题.



例如, USB 驱动能够在用户空间编写; 看(仍然年幼) libusb 项目, 在libusb.sourceforge.net 和 "gadgetfs" 在内核源码里. 另一个例子是 X 服务器: 它确切地知道它能处理哪些硬件, 哪些不能, 并且它提供图形资源给所有的 X 客户. 注意, 然而, 有一个缓慢但是固定的漂移向着基于 frame-buffer 的图形环境, X 服务器只是作为一个服务器, 基于一个内核空间的真实的设备驱动, 这个驱动负责真正的图形操作.



常常, 用户空间驱动的编写者完成一个服务器进程, 从内核接管作为单个代理的负责硬件控制的任务. 客户应用程序就可以连接到服务器来进行实际的操作; 因此, 一个聪明的驱动经常可以允许对设备的并行存取. 这就是 X 服务器如何工作的.
但是用户空间的设备驱动的方法有几个缺点. 最重要的是:

- 中断在用户空间无法用. 在某些平台上有对这个限制的解决方法, 例如在 IA32 体系上的 vm86 系统调用.
- 只可能通过内存映射 /dev/mem 来使用 DMA, 而且只有特权用户可以这样做.
- 存取 I/O 端口只能在调用 ioperm 或者 iopl 之后. 此外, 不是所有的平台支持这些系统调用, 而存取/dev/port 可能太慢而无效率. 这些系统调用和设备文件都要求特权用户.
- 响应时间慢, 因为需要上下文切换在客户和硬件之间传递信息或动作.
- 更不好的是, 如果驱动已被交换到硬盘, 响应时间会长到不可接受. 使用 mlock 系统调用可能会有帮助, 但是常常的你将需要锁住许多内存页, 因为一个用户空间程序依赖大量的库代码. mlock, 也, 限制在授权用户上.
- 最重要的设备不能在用户空间处理, 包括但不限于, 网络接口和块设备.

如你所见, 用户空间驱动不能做的事情毕竟太多. 感兴趣的应用程序还是存在: 例如, 对SCSI 扫描器设备的支持( 由 SANE 包实现 )和 CD 刻录器 ( 由 cdrecord 和别的工具实现 ). 在两种情况下, 用户级别的设备情况依赖 "SCSI gneric" 内核驱动, 它输出了低层的 SCSI 功能给用户程序, 因此它们可以驱动它们自己的硬件.一种在用户空间工作的情况可能是有意义的, 当你开始处理新的没有用过的硬件时. 这样你可以学习去管理你的硬件, 不必担心挂起整个系统. 一旦你完成了, 在一个内核模块中封装软件就会是一个简单操作了.

### 字符驱动

scull( Simple Character Utility forLoading Localities). scull 是一个字符驱动,



### scull的设计

编写驱动的第一步是定义驱动将要提供给用户程序的能力(机制).因为我们的"设备"是计算机内存的一部分, 我们可自由做我们想做的事情. 它可以是一个顺序的或者随机存取的设备, 一个或多个设备, 等等.

为使 scull 作为一个模板来编写真实设备的真实驱动, 我们将展示给你如何在计算机内存上实现几个设备抽象, 每个有不同的个性.

scull 源码实现下面的设备. 模块实现的每种设备都被引用做一种类型.
scull0 到 scull3

4 个设备, 每个由一个全局永久的内存区组成. 全局意味着如果设备被多次打开,设备中含有的数据由所有打开它的文件描述符共享. 永久意味着如果设备关闭又重新打开, 数据不会丢失. 这个设备用起来有意思, 因为它可以用惯常的命令来存取和测试, 例如 cp, cat, 以及 I/O 重定向.
scullpipe0 到 scullpipe3

4 个 FIFO (先入先出) 设备, 行为像管道. 一个进程读的内容来自另一个进程所写的. 如果多个进程读同一个设备, 它们竞争数据. scullpipe 的内部将展示阻塞读写和非阻塞读写如何实现, 而不必采取中断. 尽管真实的驱动使用硬件中断来同步它们的设备, 阻塞和非阻塞操作的主题是重要的并且与中断处理是分开的.(在第 10章涉及).
scullsingle
scullpriv
sculluid
scullwuid

这些设备与 scull0 相似, 但是在什么时候允许打开上有一些限制. 

第一个( snullsingle) 只允许一次一个进程使用驱动, 而 scullpriv 对每个虚拟终端(或者 X 终端会话)是私有的, 因为每个控制台/终端上的进程有不同的内存区.sculluid 和 scullwuid 可以多次打开, 但是一次只能是一个用户; 前者返回一个"设备忙"错误, 如果另一个用户锁着设备, 而后者实现阻塞打开. 这些 scull 的变体可能看来混淆了策略和机制, 但是它们值得看看, 因为一些实际设备需要这类管理.

每个 scull 设备演示了驱动的不同特色, 并且呈现了不同的难度. 本章涉及 scull0 到scull3 的内部; 更高级的设备在第 6 章涉及. scullpipe 在"一个阻塞 I/O 例子"一节中描述, 其他的在"设备文件上的存取控制"中描述.

#### 主次编号

字符设备通过文件系统的名字来存取。那些名字被称为文件系统的特殊文件，或者设备文件，或文件系统的简单节点；

它们常位于 /dev目录下 。

> 字符驱动的特殊文件由使用  ls -l的输出第一列的‘c'标识
>
> 块驱动的特殊文件由使用  	ls -l的输出第一列的‘b'标识

如果你发出 ls -l 命令, 你会看到在设备文件项中有 2 个数(由一个逗号分隔)在最后修
改日期前面, 这里通常是文件长度出现的地方. 这些数字是给特殊设备的主次设备编号.
下面的列表显示了一个典型系统上出现的几个设备. 它们的主编号是 1, 4, 7, 和 10, 而
次编号是 1, 3, 5, 64, 65, 和 129.

```
 crw-rw-rw- 1 root root 1, 3 Apr 11 2002 null 
 crw------- 1 root root 10, 1 Apr 11 2002 psaux 
 crw------- 1 root root 4, 1 Oct 28 03:04 tty1 
 crw-rw-rw- 1 root tty 4, 64 Apr 11 2002 ttys0 
 crw-rw---- 1 root uucp 4, 65 Apr 11 2002 ttyS1 
 crw--w---- 1 vcsa tty 7, 1 Apr 11 2002 vcs1 
 crw--w---- 1 vcsa tty 7,129 Apr 11 2002 vcsa1 
 crw-rw-rw- 1 root root 1, 5 Apr 11 2002 zero
```

传统上, 主编号标识设备相连的驱动. 例如, 

驱动1：管理/dev/null 和 /dev/zero 

驱动4：管理而虚拟控制台和串口终端同样, 

驱动7：管理vcs1 和 vcsa1 设备

现代 Linux 内核允许多个驱动共享主编号, 但是你看到的大部分设备仍然按照一个主编号一个驱动的原则来组织.

次编号被内核用来决定引用哪个设备. 依据你的驱动是如何编写的(如同我们下面见到的),你可以从内核得到一个你的设备的直接指针, 或者可以自己使用次编号作为本地设备数组的索引. 不论哪个方法, 内核自己几乎不知道次编号的任何事情, 除了它们指向你的驱动实现的设备.

...3.2.1设备编号的内部表示











### file_operations文件操作



file_operation 结构是一个字符驱动如何建立这个连接. 这个结构, 定义在<linux/fs.h>, 是一个函数指针的集合. 每个打开文件(内部用一个 file 结构来代表, 稍后我们会查看)与它自身的函数集合相关连( 通过包含一个称为 f_op 的成员, 它指向一个 file_operations 结构). 这些操作大部分负责实现系统调用, 因此, 命名为 open,read, 等等. 

传统上, 一个 file_operation 结构或者其一个指针称为 fops( 或者它的一些变体). 结构中的每个成员必须指向驱动中的函数, 这些函数实现一个特别的操作, 或者对于不支持的操作留置为 NULL. 当指定为 NULL 指针时内核的确切的行为是每个函数不同的,

在了解file_operations时会注意到不少参数包含字串 __user. 这种注解是一种文档形式, 注意, 一个指针是一个不能被直接解引用的用户空间地址. 对于正常的编译, _user 没有效果, 但是它可被外部检查软件使用来找出对用户空间地址的错误使用.

```c
struct module *owner;
//第一个 file_operations 成员根本不是一个操作; 它是一个指向拥有这个结构的模块的指针. 这个成员用来在它的操作还在被使用时阻止模块被卸载. 几乎所有时间中, 它被简单初始化为 THIS_MODULE, 一个在 <linux/module.h> 中定义的宏.
loff_t (*llseek) (struct file *, loff_t, int);
//llseek 方法用作改变文件中的当前读/写位置, 并且新位置作为(正的)返回值.loff_t 参数是一个"long offset", 并且就算在 32 位平台上也至少 64 位宽. 错误由一个负返回值指示. 如果这个函数指针是 NULL, seek 调用会以潜在地无法预知的方式修改 file 结构中的位置计数器( 在"file 结构" 一节中描述).
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
//用来从设备中获取数据. 在这个位置的一个空指针导致 read 系统调用以 -EINVAL("Invalid argument") 失败. 一个非负返回值代表了成功读取的字节数( 返回值是一个 "signed size" 类型, 常常是目标平台本地的整数类型).
ssize_t (*aio_read)(struct kiocb *, char __user *, size_t, loff_t);
//初始化一个异步读 -- 可能在函数返回前不结束的读操作. 如果这个方法是 NULL,所有的操作会由 read 代替进行(同步地).
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
//发送数据给设备. 如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数.
ssize_t (*aio_write)(struct kiocb *, const char __user *, size_t, loff_t *);
//初始化设备上的一个异步写.
int (*readdir) (struct file *, void *, filldir_t);
//对于设备文件这个成员应当为 NULL; 它用来读取目录, 并且仅对文件系统有用.
unsigned int (*poll) (struct file *, struct poll_table_struct *);
//poll 方法是 3 个系统调用的后端: poll, epoll, 和 select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞. poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的, 并且, 可能地, 提供给内核信息用来使调用进程睡眠直到I/O 变为可能. 如果一个驱动的 poll 方法为 NULL, 设备假定为不阻塞地可读可写.
int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
//ioctl 系统调用提供了发出设备特定命令的方法(例如格式化软盘的一个磁道, 这不是读也不是写). 另外, 几个 ioctl 命令被内核识别而不必引用 fops 表. 如果设备不提供 ioctl 方法, 对于任何未事先定义的请求(-ENOTTY, "设备无这样的ioctl"), 系统调用返回一个错误.
int (*mmap) (struct file *, struct vm_area_struct *);
//mmap 用来请求将设备内存映射到进程的地址空间. 如果这个方法是 NULL, mmap 系统调用返回 -ENODEV.
int (*open) (struct inode *, struct file *);
//尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知.
int (*flush) (struct file *);
//flush 操作在进程关闭它的设备文件描述符的拷贝时调用; 它应当执行(并且等待)设备的任何未完成的操作. 这个必须不要和用户查询请求的 fsync 操作混淆了. 当前, flush 在很少驱动中使用; SCSI 磁带驱动使用它, 例如, 为确保所有写的数据在设备关闭前写到磁带上. 如果 flush 为 NULL, 内核简单地忽略用户应用程序的请求.
int (*release) (struct inode *, struct file *);
//在文件结构被释放时引用这个操作. 如同 open, release 可以为 NULL.
int (*fsync) (struct file *, struct dentry *, int);
//这个方法是 fsync 系统调用的后端, 用户调用来刷新任何挂着的数据. 如果这个指针是 NULL, 系统调用返回 -EINVAL.
int (*aio_fsync)(struct kiocb *, int);
//这是 fsync 方法的异步版本.
int (*fasync) (int, struct file *, int);
//这个操作用来通知设备它的 FASYNC 标志的改变. 异步通知是一个高级的主题, 在第 6 章中描述. 这个成员可以是 NULL 如果驱动不支持异步通知.
int (*lock) (struct file *, int, struct file_lock *);
//lock 方法用来实现文件加锁; 加锁对常规文件是必不可少的特性, 但是设备驱动几乎从不实现它.
ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
//这些方法实现发散/汇聚读和写操作. 应用程序偶尔需要做一个包含多个内存区的单个读或写操作; 这些系统调用允许它们这样做而不必对数据进行额外拷贝. 如果这些函数指针为 NULL, read 和 write 方法被调用( 可能多于一次 ).
ssize_t (*sendfile)(struct file *, loff_t *, size_t, read_actor_t, void *);
//这个方法实现 sendfile 系统调用的读, 使用最少的拷贝从一个文件描述符搬移数据到另一个. 例如, 它被一个需要发送文件内容到一个网络连接的 web 服务器使用.设备驱动常常使 sendfile 为 NULL.
ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
//sendpage 是 sendfile 的另一半; 它由内核调用来发送数据, 一次一页, 到对应的文件. 设备驱动实际上不实现 sendpage.
unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
//这个方法的目的是在进程的地址空间找一个合适的位置来映射在底层设备上的内存段中. 这个任务通常由内存管理代码进行; 这个方法存在为了使驱动能强制特殊设备可能有的任何的对齐请求. 大部分驱动可以置这个方法为 NULL. [10]10
int (*check_flags)(int)
//这个方法允许模块检查传递给 fnctl(F_SETFL...) 调用的标志.
int (*dir_notify)(struct file *, unsigned long);
//这个方法在应用程序使用 fcntl 来请求目录改变通知时调用. 只对文件系统有用;驱动不需要实现 dir_notify.

```

scull 设备驱动只实现最重要的设备方法. 它的 file_operations 结构是如下初始化的:

```c
struct file_operations scull_fops = {
.owner = THIS_MODULE,
.llseek = scull_llseek,
.read = scull_read,
.write = scull_write,
.ioctl = scull_ioctl,
.open = scull_open,
.release = scull_release,
};
```

这个声明使用标准的 **C 标记式结构初始化**语法. 这个语法是首选的, 因为它使驱动在结构定义的改变之间更加可移植, 并且, 有争议地, 使代码更加紧凑和可读. 标记式初始化允许结构成员重新排序; 在某种情况下, 真实的性能提高已经实现, 通过安放经常使用的成员的指针在相同硬件高速存储行中.



...3.3.2文件结构

### copy_to_user和copy_from_user

这些函数表现象正常的 memcpy 函数, 必须加一点小心在从内核代码中存取用户空间.  寻址的用户也当前可能不在内存, 虚拟内存子系统会使进程睡眠在这个页被传送到位时.  例如, 这发生在必须从交换空间获取页的时候. 对于驱动编写者来说, 最终结果是任何存 取用户空间的函数必须是可重入的, 必须能够和其他驱动函数并行执行, 并且, 特别的,  必须在一个它能够合法地睡眠的位置. 我们在第 5 章再回到这个主题

这 2 个函数的角色不限于拷贝数据到和从用户空间: 它们还检查用户空间指针是否有效.  如果指针无效, 不进行拷贝; 如果在拷贝中遇到一个无效地址, 另一方面, 只拷贝部分数 据. 在 2 种情况下, 返回值是还要拷贝的数据量. scull 代码查看这个错误返回, 并且如 果它不是 0 就返回 -EFAULT 给用户.

```c
#include <linux/kernel.h>
container_of(pointer, type, field);
//一个传统宏定义, 可用来获取一个结构指针, 从它里面包含的某个其他结构的指针.
#include <asm/uaccess.h>
//这个包含文件声明内核代码使用的函数来移动数据到和从用户空间.
unsigned long copy_from_user (void *to, const void *from, unsigned long count);
unsigned long copy_to_user (void *to, const void *from, unsigned long count);
//在用户空间和内核空间拷贝数据.
```







### printk

有 8 种可能的记录字串, 在头文件 <linux/kernel.h> 里定义; 我们按照严重性递减的
顺序列出它们:

```C
KERN_EMERG
//用于紧急消息, 常常是那些崩溃前的消息.
KERN_ALERT
//需要立刻动作的情形.
KERN_CRIT
//严重情况, 常常与严重的硬件或者软件失效有关.
KERN_ERR
//用来报告错误情况; 设备驱动常常使用 KERN_ERR 来报告硬件故障.
KERN_WARNING
//有问题的情况的警告, 这些情况自己不会引起系统的严重问题.
KERN_NOTICE
//正常情况, 但是仍然值得注意. 在这个级别一些安全相关的情况会报告.
KERN_INFO
//信息型消息. 在这个级别, 很多驱动在启动时打印它们发现的硬件的信息.
KERN_DEBUG
//用作调试消息.
```

每个字串( 在宏定义扩展里 )代表一个在角括号中的整数. 整数的范围从 0 到 7, 越小的数表示越大的优先级.

一条没有指定优先级的 printk 语句缺省是DEFAULT_MESSAGE_LOGLEVEL, 在kernel/printk.c 里指定作为一个整数.在 2.6.10 内核中, DEFAULT_MESSAGE_LOGLEVEL是 KERN_WARNING, 但是在过去已知是改变的.

你可以使所有内核消息出现在控制台, 通过简单地输入:

echo 8 > /proc/sys/kernel/printk

现在应当清楚了为什么 hello.c 例子使用 KERN_ALERT 标志; 它们是要确保消息会出现在控制台上.

4.2.2重定向控制台消息

### 内存映射和DMA





User virtual addresses  

这是被用户程序见到的常规地址. 用户地址在长度上是 32 位或者 64 位, 依赖底 层的硬件结构, 并且每个进程有它自己的虚拟地址空间.  

Physical addresses  

在处理器和系统内存之间使用的地址. 物理地址是 32- 或者 64-位的量; 甚至  32-位系统在某些情况下可使用更大的物理地址.  

Bus addresses  

在外设和内存之间使用的地址. 经常, 它们和被处理器使用的物理地址相同, 但是这不是必要的情况. 一些体系可提供一个 I/O 内存管理单元(IOMMU), 它在总线和 主内存之间重映射地址. 一个 IOMMU 可用多种方法使事情简单(例如, 使散布在内 存中的缓冲对设备看来是连续的, 例如), 但是当设定 DMA 操作时对 IOMMU 编程是一个必须做的额外的步骤. 总线地址是高度特性依赖的, 当然.  

Kernel logical addresses  

这些组成了正常的内核地址空间. 这些地址映射了部分(也许全部)主存并且常常被 当作它们是物理内存来对待. 在大部分的体系上, 逻辑地址和它们的相关物理地址 只差一个常量偏移. 逻辑地址使用硬件的本地指针大小并且, 因此, 可能不能在重 装备的 32-位系统上寻址所有的物理内存. 逻辑地址常常存储于 unsigned long  或者 void * 类型的变量中. 从 kmalloc 返回的内存有内核逻辑地址.  

Kernel virtual addresses  

内核虚拟地址类似于逻辑地址, 它们都是从内核空间地址到物理地址的映射. 内核虚拟地址不必有逻辑地址空间具备的线性的, 一对一到物理地址的映射, 但是. 所有的逻辑地址是内核虚拟地址, 但是许多内核虚拟地址不是逻辑地址. 例如, vmalloc 分配的内存有虚拟地址(但没有直接物理映射). kmap 函数(本章稍后描述)也返回虚拟地址. 虚拟地址常常存储于指针变量. 



#### DMA

##### 总线地址

一个使用 DMA 的设备驱动必须和连接到接口总线的硬件通讯, 总线使用物理地址, 而程 序代码使用虚拟地址. 