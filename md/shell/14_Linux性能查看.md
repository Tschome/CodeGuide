https://zhuanlan.zhihu.com/p/62138848

### uptime

这个命令可以快速查看机器的负载情况。 在Linux系统中，这些数据表示等待CPU资源的进程和阻塞在不可中断IO进程（进程状态为D）的数量。
命令的输出，load average表示1分钟、5分钟、15分钟的平均负载情况。
通过这三个数据，可以了解服务器负载是在趋于紧张还是趋于缓解。
如果1分钟平均负载很高，而15分钟平均负载很低，说明服务器正在命令高负载情况，需要进一步排查CPU资源都消耗在了哪里。
反之，如果15分钟平均负载很高，1分钟平均负载较低，则有可能是CPU资源紧张时刻已经过去。

W
Show who is logged on and what they are doing.
可查询登录当前系统的用户信息，以及这些用户目前正在做什么操作
其中的load average后面的三个数字则显示了系统最近1分钟、5分钟、15分钟的系统平均负载情况
注意：load average这个输出值，这三个值的大小一般不能大于系统逻辑CPU的个数。
如果输出中系统有4个逻辑CPU，如果load average的三个值长期大于4时，说明CPU很繁忙，负载很高，可能会影响系统性能，但是偶尔大于4时，倒不用担心，一般不会影响系统性能。相反，如果load average的输出值小于CPU的个数，则表示CPU还有空闲

## dmesg | tail

该命令会输出系统日志的最后10行。
这些日志可以帮助排查性能问题.

## vmstat

vmstat Virtual Meomory Statistics（虚拟内存统计），用来获得有关进程、虚存、页面交换空间及 CPU活动的信息。这些信息反映了系统的负载情况。
后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义
\- **监控进程procs：**
r：等待在CPU资源的进程数。
这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和（出现了CPU瓶颈）。
b：在等待io的进程数 。
\- **监控内存memoy：**
swpd：现时可用的交换内存（单位KB）
free：系统可用内存数（以千字节为单位）
buff: 缓冲去中的内存数（单位：KB）。
cache：被用来做为高速缓存的内存数（单位：KB）。
\- **监控swap交换页面**
si: 从磁盘交换到内存的交换页数量，单位：KB/秒。
so: 从内存交换到磁盘的交换页数量，单位：KB/秒。 　　 如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。
\- **监控 io块设备**
bi: 发送到块设备的块数，单位：块/秒。
bo: 从块设备接收到的块数，单位：块/秒。
\- **监控system系统**
in: 每秒的中断数，包括时钟中断。
cs: 每秒的环境（上下文）转换次数。
\- **监控cpu中央处理器：**
us：用户进程使用的时间 。以百分比表示。
sy：系统进程使用的时间。 以百分比表示。
id：中央处理器的空闲时间 。以百分比表示。
　　us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。
这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。
注：
　　 如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。
　　 如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。 　　 　　 如果有大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。

## mpstat -P ALL 1

该命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么有可能是一个单线程应用程序引起的。
MultiProcessor Statistics的缩写，是实时系统监控工具
其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。
格式：mpstat [-P {|ALL}] [internal [count]] -P {|ALL} 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值 internal 相邻的两次采样的间隔时间
count 采样的次数，count只能和delay一起使用
　　all ： 指所有CPU
　　%usr ： 显示在用户级别（例如应用程序）执行时CPU利用率的百分比
　　%nice ：显示在拥有nice优先级的用户级别执行时CPU利用率的百分比
　　%sys ： 现实在系统级别（例如内核）执行时CPU利用率的百分比
　　%iowait ： 显示在系统有未完成的磁盘I/O请求期间CPU空闲时间的百分比
　　%irq ： 显示CPU服务硬件中断所花费时间的百分比
　　%soft ： 显示CPU服务软件中断所花费时间的百分比
　　%steal ： 显示虚拟机管理器在服务另一个虚拟处理器时虚拟CPU处在非自愿等待下花费时间的百分比
　　%guest ： 显示运行虚拟处理器时CPU花费时间的百分比
　　%idle ： 显示CPU空闲和系统没有未完成的磁盘I/O请求情况下的时间百分比
系统有两个CPU。如果使用参数 -P 然后紧跟CPU编号得到指定CPU的利用率。
`（ Ubuntu安装： apt-get install sysstat）`

## pidstat 1

pidstat命令输出进程的CPU占用率，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态

## iostat -xz 1

iostat命令主要用于查看机器磁盘IO情况
r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。
await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。
avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。
%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。
注：如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能

free -m

free命令可以查看系统内存的使用情况，-m参数表示按照兆字节展示。
最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。
注：
　　第二行-/+ buffers/cache，看上去缓存占用了大量内存空间。这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。
　　如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。

## sar -n DEV 1

sar命令在这里可以查看网络设备的吞吐率。
在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。

## sar -n TCP,ETCP 1

sar命令在这里用于查看TCP连接状态，其中包括：
active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；
passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；
retrans/s：每秒TCP重传数量；
TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包。

## top

```text
top命令包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。
 因此通过这个命令，可以相对全面的查看系统负载的来源。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。
 但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。  
```



## c语言linux打印运行时间（耗时） gettimeofday()、timeval、＜sys/time.h＞

```c
#include <stdio.h>
#include <sys/time.h>

double __get_us(struct timeval t) { 
	return (t.tv_sec * 1000000 + t.tv_usec); 
}

int main(){
	struct timeval start_time, stop_time;
	gettimeofday(&start_time, NULL);

	//待运行代码

	gettimeofday(&stop_time, NULL);
	printf("Time use %f ms\n", (__get_us(stop_time) - __get_us(start_time)) / 1000);
}


```

cat /proc/jz/clock/clocks | grep ddr